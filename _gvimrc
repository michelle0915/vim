let $HOME='C:/vim'

" テーマ
" ホームディレクトリ
colorscheme evening
set encoding=utf-8
set fileencodings=utf-8,cp932,sjis
set guifont=HGGothicM:h12:b
set guifontwide=HGGothicM:h12:b
source $VIMRUNTIME/delmenu.vim
set langmenu=ja_jp.utf-8
source $VIMRUNTIME/menu.vim

" ウインドウの幅
set columns=100
" ウインドウの高さ
set lines=50

" 自動生成ファイルを生成しない
set noswapfile
set nobackup
set viminfo=
set noundofile
set hidden

" ウィンドウ表示設定
set number
set hlsearch
set showtabline=3
set expandtab
set tabstop=4
set shiftwidth=4
set nowrap
set cursorline
set scrolloff=2
set textwidth=0
"set virtualedit=onemore
set nolist
set listchars=tab:>-,trail:-

" 対応括弧のペアを追加
set matchpairs+=<:>
set matchpairs+=（:）
set matchpairs+=【:】

" ビープ音を消す
set vb t_vb=

" leader
let mapleader="\<space>"
nnoremap <leader>s :set 
nnoremap <leader>g :vimgrep  **/*<left><left><left><left><left>
nnoremap <leader>l :ls<cr>
nnoremap <leader>r :source ~/_gvimrc<cr>
nnoremap <silent> <leader>e :q<cr>
nnoremap <leader>w :w<cr>
nnoremap <leader>o :tabnew<cr>:e 
nnoremap <silent> <leader>j :call JumpToPairTag()<cr>

noremap , <nop>
nnoremap <silent> ,w :call ToggleSetting("wrap")<cr>
nnoremap <silent> ,l :call ToggleSetting("list")<cr>
nnoremap <silent> ,n :call ToggleSetting("number")<cr>
nnoremap <silent> ,t :call ToggleSetting("expandtab")<cr>

noremap <f1> :help 
" vimrcを開く
noremap <f2> :tabnew<cr>:e $home/_gvimrc<cr>

" 画面分割、タブ関連
nnoremap s <nop>
nnoremap sn gt
nnoremap sp gT
nnoremap sj <c-w>w

" 基本操作キーマップ
nnoremap <silent> <esc> <esc>:nohlsearch<cr>
noremap <c-z> <nop>
noremap j gj
noremap k gk
noremap <c-h> ^
noremap <c-l> $
noremap <c-e> 2<c-e>
noremap <c-y> 2<c-y>
nnoremap <c-u> <c-r>
noremap <c-j> /
noremap <silent> <c-k> "zyiw:let @/ = '\<' . @z . '\>'<cr>
noremap <c-n> %
noremap gy "*y
noremap gp "*p

nnoremap gu gUiw
nnoremap gl guiw

nnoremap <silent> <s-down> :call MoveLine("DOWN")<cr>
nnoremap <silent> <s-up> :call MoveLine("UP")<cr>

noremap <c-up> <c-b>
noremap <c-down> <c-f>
noremap <c-right> 3zl
noremap <c-left> 3zh

" メモリ・ジャンプ
nnoremap m mm
nnoremap <leader>m 'm

" マクロ
noremap q <nop>
noremap <f5> qa
noremap <f6> q
noremap <f8> @a

" 入力中キーバインド
inoremap <c-f> <right>
inoremap <c-b> <left>
inoremap <c-d> <del>
inoremap <c-t> <c-v><tab>
 
" 括弧入力補完
inoremap ( ()<left>
inoremap [ []<left>
inoremap { {}<left>
inoremap " ""<left>
inoremap ' ''<left>

inoremap {<cr> {}<left><cr><esc><s-o>

vnoremap (  <esc>:call Wrap("(", ")")<cr>
vnoremap [  <esc>:call Wrap("[", "]")<cr>
vnoremap {  <esc>:call Wrap("{", "}")<cr>
vnoremap "  <esc>:call Wrap("\"", "\"")<cr>
vnoremap '  <esc>:call Wrap("\'", "\'")<cr>

vnoremap <cr> y/<c-r>"<cr>

" Quickfixフック
autocmd QuickFixCmdPre vimgrep tabnew
autocmd QuickFixCmdPost vimgrep cwindow

" 自作コマンド読み込み
:source ~/_mycommand.vim

" netrw.vim設定
let g:netrw_liststyle = 3
let g:netrw_list_hide = '\(^\|\s\s\)\zs\.\S\+'
let g:netrw_altv = 1
let g:netrw_alto = 1

noremap <F9> :tabnew<cr>:e .<cr>

" ディレクトリ移動
nnoremap <m-i> :call UpDirectory()<cr>
nnoremap <m-u> :call BackToPrevDirectory()<cr>
nnoremap <m-p> :pwd<cr>
nnoremap <m-j> :cd 

function! CreatePathHistory()
    if !exists("w:pathHistory")
        let w:pathHistory = []
    endif
endfunction

function! PushPath()
    call CreatePathHistory()
    call add(w:pathHistory, getcwd())
endfunction

function! PopPath()
    call CreatePathHistory()
    let s:len = len(w:pathHistory)
    if s:len > 0
        return remove(w:pathHistory,  s:len - 1)
    else
        return -1
    endif
endfunction

function! UpDirectory()
    call PushPath()
    execute "lcd .."
    execute "pwd"
endfunction

function! BackToPrevDirectory()
    let s:prev = PopPath()
    if s:prev != -1
        execute "lcd " . s:prev
    endif
    execute "pwd"
endfunction

" 最下ウィンドウにステータスバーを常に表示する
set laststatus=2
 
" ステータスバーの内容
"set statusline=%1*
set statusline =
set statusline+=\ [%n]                                     " バッファ番号
set statusline+=\ %<%t                                     " ファイル名
set statusline+=%r%H%W%m                                   " ファイルステータス
"set statusline+=\ [Type:%{strlen(&ft)?&ft:'unknown'}]      " ファイルタイプ
set statusline+=\ [Enc/Fmt:%{strlen(&fenc)?&fenc:'unknown'}/%{GetFileFormat()}]   " ファイルエンコーディング/ファイルフォーマット( 改行コード )
set statusline+=\ %{&bomb?'[BOM]':''}                      " BOM の有無
set statusline+=%=                                         " 以下、右寄せで表示
set statusline+=\ [Ascii:%03b/0x%02B]                             " ASCII コード ( 10進/16進 )
"set statusline+=\ [Pos:%03v\ %l/%L]                        " カーソル位置の列 / 行、全行数
set statusline+=\ [Line:%l/%L]                             " カーソル位置の列 / 行、全行数
set statusline+=\                                          " パディング
 
" ファイルフォーマットを改行コードに変換
function! GetFileFormat()
    if &ff == 'unix'
        return 'LF'
    elseif &ff == 'dos'
        return 'CRLF'
    elseif &ff == 'mac'
        return 'CR'
    else
        return 'unknown'
    endif
endfunction

" オプションのON/OFF切替え
function! ToggleSetting(op)
    if eval("&" . a:op)
        execute "set no" . a:op
        echo "set no" . a:op
    else
        execute "set " . a:op
        echo "set " . a:op
    endif
endfunction

" 対となる開始・終了タグに移動する
function! JumpToPairTag()
    " カーソル位置の括弧を含むタグ文字列を取得（マルチバイト文字も考慮して、以後扱う）
    execute "normal! va<\<esc>"
    let s:tagstring = GetSelectedString()

    " 対のないタグの場合、なにもしない
    if strcharpart(s:tagstring, strchars(s:tagstring) - 2) == '/>'
        return
    endif

    " タグ名のみ取得
    let s:tagname = strcharpart(s:tagstring, 1, strchars(s:tagstring) - 2)
    " 属性値が設定されている場合
    let s:spaceIndex = stridx(s:tagname, " ")
    if (s:spaceIndex != -1)
        let s:tagname = strpart(s:tagname, 0, s:spaceIndex)
    endif

    " 開始/終了タグに応じて下/上検索
    if s:tagname[0] != '/'
        let s:res = searchpair('<'.s:tagname.'.\{-}>', '', '</'.s:tagname.'>', 'W')
    else
        let s:tagname = s:tagname[1:]
        let s:res = searchpair('<'.s:tagname.'.\{-}>', '', '</'.s:tagname.'>', 'bW')
    endif

endfunction

" 25%/75%の位置に移動できる
" 着地点を予測しにくいため、使い勝手がイマイチ
function! ThreeQuarter(pos)
    execute "normal! H"
    let s:rowH = line('.')
    execute "normal! L"
    let s:rowL = line('.')
    execute "normal! M"
    let s:rowM = line('.')

    let s:rowMH = ( s:rowH + s:rowM ) / 2
    let s:rowML = ( s:rowL + s:rowM ) / 2

    if a:pos == "h"
        execute "normal! " . s:rowMH . "G"
    else
        execute "normal! " . s:rowML . "G"
    endif
endfunction

" 選択範囲の文字列を取得
function! GetSelectedString()

    let s:ret = ""
    let s:tmp = @@
    execute "normal! gvy"
    let s:ret = @@
    let @@ = s:tmp

    return s:ret
endfunction

" 指定の文字で選択範囲を囲む
function! Wrap(pre, sur)
    let s:tmp = @@

    execute "normal! gvc" . a:pre . "\<c-r>\"" . a:sur . "\<esc>"

    let @@ = s:tmp
endfunction

" コメントアウト
function! CommentOut(commentString)
    execute "normal! 0i" . a:commentString . "\<esc>"
endfunction

" コメントアウト解除
function! UnCommentOut(commentString)
    let s:tmp = @@

    let s:line = getline('.')
    if match(s:line, '^\s*'.a:commentString) == -1
        return
    endif
    execute "normal! ^" . repeat("x", len(a:commentString))

    let @@ = s:tmp
endfunction

" 複数行コメントアウト/解除
function! CommentOutMultiLine(commentString)
    call MultiLineCall('CommentOut', [a:commentString])
endfunction

function! UnCommentOutMultiLine(commentString)
    call MultiLineCall('UnCommentOut', [a:commentString])
endfunction

let filetypeCommentStr = ""
augroup fileTypeComment
    autocmd!
    autocmd BufNewFile,BufRead *.vim,*vimrc let filetypeCommentStr = '"'
    autocmd BufNewFile,BufRead *.lisp let filetypeCommentStr = ';'
    autocmd BufNewFile,BufRead *.c,*.cpp let filetypeCommentStr = '//'
    autocmd BufNewFile,BufRead *.js let filetypeCommentStr = '//'
    autocmd BufNewFile,BufRead *.java let filetypeCommentStr = '//'
    autocmd BufNewFile,BufRead *.php let filetypeCommentStr = '//'
    autocmd BufNewFile,BufRead *.pl let filetypeCommentStr = '#'
    autocmd BufNewFile,BufRead *.py let filetypeCommentStr = '#'
augroup END

nnoremap <silent> - :call CommentOut(filetypeCommentStr)<cr>
nnoremap <silent> + :call UnCommentOut(filetypeCommentStr)<cr>
vnoremap <silent> - <esc>:call CommentOutMultiLine(filetypeCommentStr)<cr>gv
vnoremap <silent> + <esc>:call UnCommentOutMultiLine(filetypeCommentStr)<cr>gv

" 複数行にわたる関数実行
function! MultiLineCall(funcName, args)
    execute "normal! `<"
    let s:startLine = line('.')
    execute "normal! `>"
    let s:endLine = line('.')

    let s:fn = function(a:funcName, a:args)

    for eachLine in range(s:startLine, s:endLine)
        execute "normal! " . eachLine . "G"
        call s:fn()
    endfor
endfunction

function! Hello()
    echo "hello"
endfunction
