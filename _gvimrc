let $HOME='C:/Users/akamatsu-m/vim'

" テーマ
" ホームディレクトリ
colorscheme evening
set encoding=utf-8
set fileencodings=utf-8,cp932,sjis
set guifont=HGGothicM:h12:b
set guifontwide=HGGothicM:h12:b
source $VIMRUNTIME/delmenu.vim
set langmenu=ja_jp.utf-8
source $VIMRUNTIME/menu.vim

" ウインドウの幅
set columns=100
" ウインドウの高さ
set lines=50

" 自動生成ファイルを生成しない
set noswapfile
set nobackup
set viminfo=
set noundofile
set hidden

" ウィンドウ表示設定
set number
set hlsearch
set showtabline=3
set noexpandtab
set tabstop=4
set shiftwidth=4
set nowrap
set cursorline
set scrolloff=2
set textwidth=0
"set virtualedit=onemore
set nolist
set listchars=tab:>-,trail:-

" 対応括弧のペアを追加
set matchpairs+=<:>
set matchpairs+=（:）
set matchpairs+=【:】

" ビープ音を消す
set vb t_vb=

" leader
let mapleader="\<space>"
nnoremap <leader>s :set 
nnoremap <leader>g :vimgrep  **/*<left><left><left><left><left>
nnoremap <leader>l :ls<cr>
nnoremap <leader>r :source ~/_gvimrc<cr>
nnoremap <silent> <leader>e :q<cr>
nnoremap <leader>w :w<cr>
nnoremap <leader>o :tabnew<cr>:e 
nnoremap <silent> <leader>j :call JumpToPairTag()<cr>

nnoremap <silent> <f4>w :call ToggleSetting("wrap")<cr>
nnoremap <silent> <f4>l :call ToggleSetting("list")<cr>
nnoremap <silent> <f4>n :call ToggleSetting("number")<cr>
nnoremap <silent> <f4>t :call ToggleSetting("expandtab")<cr>

noremap <f1> :help 
" vimrcを開く
noremap <f2> :tabnew<cr>:e $home/_gvimrc<cr>

" 画面分割、タブ関連
nnoremap s <nop>
nnoremap sn gt
nnoremap sp gT
nnoremap sj <c-w>w

" 基本操作キーマップ
nnoremap <silent> <esc> <esc>:nohlsearch<cr>
noremap <c-z> <nop>
noremap j gj
noremap k gk
noremap <c-h> ^
noremap <c-l> $
noremap <c-e> 2<c-e>
noremap <c-y> 2<c-y>
nnoremap <c-u> <c-r>
noremap <c-j> /
noremap <c-k> *
noremap <c-n> %
noremap gy "*y
noremap gp "*p

nnoremap gu gUiw
nnoremap gl guiw

nnoremap <silent> <s-down> :call MoveLine("DOWN")<cr>
nnoremap <silent> <s-up> :call MoveLine("UP")<cr>

noremap <c-up> <c-b>
noremap <c-down> <c-f>
noremap <c-right> 3zl
noremap <c-left> 3zh

" メモリ・ジャンプ
nnoremap m mm
nnoremap <leader>m 'm

" マクロ
noremap q <nop>
noremap <f5> qa
noremap <f6> q
noremap <f8> @a

" 入力中キーバインド
inoremap <c-f> <right>
inoremap <c-b> <left>
inoremap <c-d> <del>
inoremap <c-t> <c-v><tab>
 
" 括弧入力補完
inoremap ( ()<left>
inoremap [ []<left>
inoremap { {}<left>
inoremap " ""<left>
inoremap ' ''<left>

inoremap {<cr> {}<left><cr><esc><s-o>

vnoremap ( di(<c-r>")<esc>
vnoremap [ di(<c-r>"]<esc>
vnoremap { di{<c-r>"}<esc>
vnoremap " di"<c-r>""<esc>
vnoremap ' di'<c-r>"'<esc>

vnoremap <cr> y/<c-r>"<cr>

" Quickfixフック
autocmd QuickFixCmdPre vimgrep tabnew
autocmd QuickFixCmdPost vimgrep cwindow

" 自作コマンド読み込み
:source ~/_mycommand.vim

" netrw.vim設定
let g:netrw_liststyle = 3
let g:netrw_list_hide = '\(^\|\s\s\)\zs\.\S\+'
let g:netrw_altv = 1
let g:netrw_alto = 1

noremap <F9> :tabnew<cr>:e .<cr>

" ディレクトリ移動
nnoremap <m-i> :call UpDirectory()<cr>
nnoremap <m-u> :call BackToPrevDirectory()<cr>
nnoremap <m-p> :pwd<cr>
nnoremap <m-j> :cd 

function! CreatePathHistory()
	if !exists("w:pathHistory")
		let w:pathHistory = []
	endif
endfunction

function! PushPath()
	call CreatePathHistory()
	call add(w:pathHistory, getcwd())
endfunction

function! PopPath()
	call CreatePathHistory()
	let s:len = len(w:pathHistory)
	if s:len > 0
		return remove(w:pathHistory,  s:len - 1)
	else
		return -1
	endif
endfunction

function! UpDirectory()
	call PushPath()
	execute "lcd .."
	execute "pwd"
endfunction

function! BackToPrevDirectory()
	let s:prev = PopPath()
	if s:prev != -1
		execute "lcd " . s:prev
	endif
	execute "pwd"
endfunction

" 最下ウィンドウにステータスバーを常に表示する
set laststatus=2
 
" ステータスバーの内容
"set statusline=%1*
set statusline =
set statusline+=\ [%n]                                     " バッファ番号
set statusline+=\ %<%t                                     " ファイル名
set statusline+=%r%H%W%m                                   " ファイルステータス
"set statusline+=\ [Type:%{strlen(&ft)?&ft:'unknown'}]      " ファイルタイプ
set statusline+=\ [Enc/Fmt:%{strlen(&fenc)?&fenc:'unknown'}/%{GetFileFormat()}]   " ファイルエンコーディング/ファイルフォーマット( 改行コード )
set statusline+=\ %{&bomb?'[BOM]':''}                      " BOM の有無
set statusline+=%=                                         " 以下、右寄せで表示
set statusline+=\ [Ascii:%03b/0x%02B]                             " ASCII コード ( 10進/16進 )
"set statusline+=\ [Pos:%03v\ %l/%L]                        " カーソル位置の列 / 行、全行数
set statusline+=\ [Line:%l/%L]                             " カーソル位置の列 / 行、全行数
set statusline+=\                                          " パディング
 
" ファイルフォーマットを改行コードに変換
function! GetFileFormat()
    if &ff == 'unix'
        return 'LF'
    elseif &ff == 'dos'
        return 'CRLF'
    elseif &ff == 'mac'
        return 'CR'
    else
        return 'unknown'
    endif
endfunction

" オプションのON/OFF切替え
function! ToggleSetting(op)
	if eval("&" . a:op)
		execute "set no" . a:op
		echo "set no" . a:op
	else
		execute "set " . a:op
		echo "set " . a:op
	endif
endfunction

" 対となる開始・終了タグに移動する
function! JumpToPairTag()
	" カーソル位置の括弧を含むタグ文字列を取得（マルチバイト文字も考慮して、以後扱う）
	let s:tagstring = ""
	let s:tmp = @@
	execute "normal! va<y"
	let s:tagstring = @@
	let @@ = s:tmp

	" 対のないタグの場合、なにもしない
	if strcharpart(s:tagstring, strchars(s:tagstring) - 2) == '/>'
		return
	endif

	" タグ名のみ取得
	let s:tagname = strcharpart(s:tagstring, 1, strchars(s:tagstring) - 2)
	" 属性値が設定されている場合
	let s:spaceIndex = stridx(s:tagname, " ")
	if (s:spaceIndex != -1)
		let s:tagname = strpart(s:tagname, 0, s:spaceIndex)
	endif

	" 開始/終了タグに応じて下/上検索
	if s:tagname[0] != '/'
		let s:res = searchpair('<'.s:tagname.'.\{-}>', '', '</'.s:tagname.'>', 'W')
	else
		let s:tagname = s:tagname[1:]
		let s:res = searchpair('<'.s:tagname.'.\{-}>', '', '</'.s:tagname.'>', 'bW')
	endif

endfunction

" 25%/75%の位置に移動できる
" 着地点を予測しにくいため、使い勝手がイマイチ
function! ThreeQuarter(pos)
	execute "normal! H"
	let s:rowH = line('.')
	execute "normal! L"
	let s:rowL = line('.')
	execute "normal! M"
	let s:rowM = line('.')

	let s:rowMH = ( s:rowH + s:rowM ) / 2
	let s:rowML = ( s:rowL + s:rowM ) / 2

	if a:pos == "h"
		execute "normal! " . s:rowMH . "G"
	else
		execute "normal! " . s:rowML . "G"
	endif
endfunction
