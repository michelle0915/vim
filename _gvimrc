" ホームディレクトリ
let $HOME='C:/Users/akamatsu-m/vim'

" テーマ
colorscheme evening
set encoding=utf-8
set fileencodings=utf-8,cp932,sjis
set guifont=HGGothicM:h12:b
set guifontwide=HGGothicM:h12:b
source $VIMRUNTIME/delmenu.vim
set langmenu=ja_jp.utf-8
source $VIMRUNTIME/menu.vim

" ウインドウの幅
set columns=100
" ウインドウの高さ
set lines=50

" 自動生成ファイルを生成しない
set noswapfile
set nobackup
set viminfo=
set noundofile
set hidden

" ウィンドウ表示設定
set number
set hlsearch
set showtabline=3
set expandtab
set tabstop=4
set shiftwidth=4
set nowrap
set cursorline
set scrolloff=2
set textwidth=0
set guioptions-=m "メニューバー
set guioptions-=T "ツールバー
set guioptions-=r "スクロールバー
set guioptions-=R
set guioptions-=l
set guioptions-=L
set guioptions-=b

"set virtualedit=onemore
set nolist
set listchars=tab:>-,trail:-

" 対応括弧のペアを追加
set matchpairs+=<:>
set matchpairs+=（:）
set matchpairs+=【:】

" ビープ音を消す
set vb t_vb=

" leader
let mapleader="\<space>"
nnoremap <leader>s :set 
nnoremap <leader>g :vimgrep  **/*<left><left><left><left><left>
nnoremap <leader>l :ls<cr>
nnoremap <leader>r :source ~/_gvimrc<cr>
nnoremap <silent> <leader>e :q<cr>
nnoremap <leader>w :w<cr>
nnoremap <leader>o :tabnew<cr>:e 
nnoremap <silent> <leader>j :call JumpToPairTag()<cr>

noremap , <nop>
nnoremap <silent> ,w :call ToggleSetting("wrap")<cr>
nnoremap <silent> ,l :call ToggleSetting("list")<cr>
nnoremap <silent> ,n :call ToggleSetting("number")<cr>
nnoremap <silent> ,t :call ToggleSetting("expandtab")<cr>

noremap <f1> :help 
" vimrcを開く
noremap <f2> :tabnew<cr>:e $home/_gvimrc<cr>

" 画面分割、タブ関連
nnoremap s <nop>
nnoremap sn gt
nnoremap sp gT
nnoremap sj <c-w>w

" 基本操作キーマップ
nnoremap <silent> <esc> <esc>:nohlsearch<cr>
noremap <c-z> <nop>
noremap j gj
noremap k gk
noremap <c-h> ^
noremap <c-l> $
noremap <c-e> 2<c-e>
noremap <c-y> 2<c-y>
nnoremap <c-u> <c-r>
noremap <c-j> /
"noremap <silent> <c-k> "zyiw:let @/ = '\<' . @z . '\>'<cr>:set hlsearch<cr>
noremap <silent> <c-k> :call Highlight()<cr>:set hlsearch<cr>
noremap <c-n> %
noremap gy "*y
noremap gp "*p

nnoremap gu gUiw
nnoremap gl guiw

nnoremap <silent> <s-down> :call MoveLine("DOWN")<cr>
nnoremap <silent> <s-up> :call MoveLine("UP")<cr>
vnoremap <silent> <s-down> <esc>:call MoveMultiLine("DOWN")<cr>
vnoremap <silent> <s-up> <esc>:call MoveMultiLine("UP")<cr>

noremap <c-up> <c-b>
noremap <c-down> <c-f>
noremap <c-right> 3zl
noremap <c-left> 3zh

" マクロ
noremap q <nop>
noremap <f5> qa
noremap <f6> q
noremap <f8> @a

" 入力中キーバインド
inoremap <c-f> <right>
inoremap <c-b> <left>
inoremap <c-d> <del>
inoremap <c-t> <c-v><tab>
 
" 括弧入力補完
inoremap ( ()<left>
inoremap [ []<left>
inoremap { {}<left>
inoremap " ""<left>
inoremap ' ''<left>

inoremap {<cr> {}<left><cr><esc><s-o>

vnoremap ( <esc>:call Wrap("(", ")")<cr>
vnoremap [ <esc>:call Wrap("[", "]")<cr>
vnoremap { <esc>:call Wrap("{", "}")<cr>
vnoremap < <esc>:call Wrap("<", ">")<cr>
vnoremap " <esc>:call Wrap("\"", "\"")<cr>
vnoremap ' <esc>:call Wrap("\'", "\'")<cr>
vnoremap g( <esc>:call Wrap("（", "）")<cr>
vnoremap g[ <esc>:call Wrap("【", "】")<cr>

vnoremap <cr> y/<c-r>"<cr>

" Quickfixフック
autocmd QuickFixCmdPre vimgrep tabnew
autocmd QuickFixCmdPost vimgrep cwindow

" 自作コマンド読み込み
:source ~/_mycommand.vim

" netrw.vim設定
let g:netrw_liststyle = 3
let g:netrw_list_hide = '\(^\|\s\s\)\zs\.\S\+'
let g:netrw_altv = 1
let g:netrw_alto = 1

noremap <F9> :tabnew<cr>:e .<cr>

" ディレクトリ移動
nnoremap <m-i> :call UpDirectory()<cr>
nnoremap <m-u> :call BackToPrevDirectory()<cr>
nnoremap <m-p> :pwd<cr>
nnoremap <m-j> :cd 

function! CreatePathHistory()
    if !exists("w:pathHistory")
        let w:pathHistory = []
    endif
endfunction

function! PushPath()
    call CreatePathHistory()
    call add(w:pathHistory, getcwd())
endfunction

function! PopPath()
    call CreatePathHistory()
    let len = len(w:pathHistory)
    if len > 0
        return remove(w:pathHistory,  len - 1)
    else
        return -1
    endif
endfunction

function! UpDirectory()
    call PushPath()
    execute "lcd .."
    execute "pwd"
endfunction

function! BackToPrevDirectory()
    let prev = PopPath()
    if prev != -1
        execute "lcd " . prev
    endif
    execute "pwd"
endfunction

" 最下ウィンドウにステータスバーを常に表示する
set laststatus=2
 
" ステータスバーの内容
"set statusline=%1*
set statusline =
set statusline+=\ [%n]                                     " バッファ番号
set statusline+=\ %<%t                                     " ファイル名
set statusline+=%r%H%W%m                                   " ファイルステータス
"set statusline+=\ [Type:%{strlen(&ft)?&ft:'unknown'}]      " ファイルタイプ
set statusline+=\ [Enc/Fmt:%{strlen(&fenc)?&fenc:'unknown'}/%{GetFileFormat()}]   " ファイルエンコーディング/ファイルフォーマット( 改行コード )
set statusline+=\ %{&bomb?'[BOM]':''}                      " BOM の有無
set statusline+=%=                                         " 以下、右寄せで表示
set statusline+=\ [Ascii:%03b/0x%02B]                             " ASCII コード ( 10進/16進 )
"set statusline+=\ [Pos:%03v\ %l/%L]                        " カーソル位置の列 / 行、全行数
set statusline+=\ [Line:%l/%L\ Col:%c]                             " カーソル位置の列 / 行、全行数
set statusline+=\                                          " パディング
 
" ファイルフォーマットを改行コードに変換
function! GetFileFormat()
    if &ff == 'unix'
        return 'LF'
    elseif &ff == 'dos'
        return 'CRLF'
    elseif &ff == 'mac'
        return 'CR'
    else
        return 'unknown'
    endif
endfunction

" オプションのON/OFF切替え
function! ToggleSetting(op)
    if eval("&" . a:op)
        execute "set no" . a:op
        echo "set no" . a:op
    else
        execute "set " . a:op
        echo "set " . a:op
    endif
endfunction

" 対となる開始・終了タグに移動する
function! JumpToPairTag()
    " カーソル位置の括弧を含むタグ文字列を取得（マルチバイト文字も考慮して、以後扱う）
    execute "normal! va<\<esc>"
    let tagstring = GetSelectedString()

    " 対のないタグの場合、なにもしない
    if strcharpart(tagstring, strchars(tagstring) - 2) == '/>'
        return
    endif

    " タグ名のみ取得
    let tagname = strcharpart(tagstring, 1, strchars(tagstring) - 2)
    " 属性値が設定されている場合
    let spaceIndex = stridx(tagname, " ")
    if (spaceIndex != -1)
        let tagname = strpart(tagname, 0, spaceIndex)
    endif

    " 開始/終了タグに応じて下/上検索
    if tagname[0] != '/'
        let res = searchpair('<'.tagname.'.\{-}>', '', '</'.tagname.'>', 'W')
    else
        let tagname = tagname[1:]
        let res = searchpair('<'.tagname.'.\{-}>', '', '</'.tagname.'>', 'bW')
    endif

endfunction

" 25%/75%の位置に移動できる
" 着地点を予測しにくいため、使い勝手がイマイチ
function! ThreeQuarter(pos)
    execute "normal! H"
    let rowH = line('.')
    execute "normal! L"
    let rowL = line('.')
    execute "normal! M"
    let rowM = line('.')

    let rowMH = ( rowH + rowM ) / 2
    let rowML = ( rowL + rowM ) / 2

    if a:pos == "h"
        execute "normal! " . rowMH . "G"
    else
        execute "normal! " . rowML . "G"
    endif
endfunction

" 選択範囲の文字列を取得
function! GetSelectedString()

    let ret = ""
    let tmp = @@
    execute "normal! gvy"
    let ret = @@
    let @@ = tmp

    return ret
endfunction

" 指定の文字で選択範囲を囲む
function! Wrap(pre, sur)
    let tmp = @@

    execute "normal! gvc" . a:pre . "\<c-r>\"" . a:sur . "\<esc>"

    let @@ = tmp
endfunction

" カーソル位置の単語をハイライト（*の移動しない版）
function! Highlight()
    let tmp = @@

    execute "normal! viwy"
    let @/ = '\<' . @@ . '\>'
"    なぜか反応しない、呼び出し元で実行（妥協）
"    set hlsearch

    let @@ = tmp
endfunction

" コメントアウト
function! CommentOut(commentString)
    execute "normal! 0i" . a:commentString . "\<esc>"
endfunction

" コメントアウト解除
function! UnCommentOut(commentString)
    let tmp = @@

    let line = getline('.')
    if match(line, '^\s*'.a:commentString) == -1
        return
    endif
    execute "normal! ^" . repeat("x", len(a:commentString))

    let @@ = tmp
endfunction

" 複数行コメントアウト/解除
function! CommentOutMultiLine(commentString)
    call MultiLineCall('CommentOut', [a:commentString])
endfunction

function! UnCommentOutMultiLine(commentString)
    call MultiLineCall('UnCommentOut', [a:commentString])
endfunction

function! FiletypeCommentStr()
    if &ft == 'vim'
        return '"'
    elseif &ft == 'lisp'
        return ';'
    elseif &ft == 'c' || &ft == 'java' || &ft == 'javascript' || &ft == 'php'
        return '//'
    elseif &ft == 'perl' || &ft == 'python'
        return '#'
    endif
endfunction

"let filetypeCommentStr = ""
"augroup fileTypeComment
"    autocmd!
"    autocmd BufNewFile,BufRead *.vim,*vimrc let filetypeCommentStr = '"'
"    autocmd BufNewFile,BufRead *.lisp let filetypeCommentStr = ';'
"    autocmd BufNewFile,BufRead *.c,*.cpp let filetypeCommentStr = '//'
"    autocmd BufNewFile,BufRead *.js let filetypeCommentStr = '//'
"    autocmd BufNewFile,BufRead *.java let filetypeCommentStr = '//'
"    autocmd BufNewFile,BufRead *.php let filetypeCommentStr = '//'
"    autocmd BufNewFile,BufRead *.pl let filetypeCommentStr = '#'
"    autocmd BufNewFile,BufRead *.py let filetypeCommentStr = '#'
"augroup END

nnoremap <silent> - :call CommentOut(FiletypeCommentStr())<cr>
nnoremap <silent> + :call UnCommentOut(FiletypeCommentStr())<cr>
vnoremap <silent> - <esc>:call CommentOutMultiLine(FiletypeCommentStr())<cr>gv
vnoremap <silent> + <esc>:call UnCommentOutMultiLine(FiletypeCommentStr())<cr>gv

" 行移動
function! MoveLine(direction)
    let tmp = @@

    let currentLine = line(".")
    let minLine = 1
    let maxLine = line("$")

    "下移動
    if a:direction == "DOWN"
        if currentLine == maxLine
            "最下行の場合、下に新たに空行を追加して移動
            execute "normal! ddo\<ESC>p"
        else
            execute "normal! ddp"
        endif

    "上移動
    elseif a:direction == "UP"
        if currentLine == minLine
            "最上行の場合、何もしない
            return
        elseif currentLine == maxLine
            "最下行の場合、カーソル行が上にずれるため、kが必要無い
            execute "normal! ddP"
        else
            execute "normal! ddkP"
        endif
    endif

    let @@ = tmp
endfunction

" 複数行移動
function! MoveMultiLine(direction)
    let tmp = @@

    let minLine = 1
    let maxLine = line("$")

    execute "normal! `<"
    let topLine = line('.')
    execute "normal! `>"
    let bottomLine = line('.')

    "下移動
    if a:direction == "DOWN"
        if bottomLine == maxLine
            "最下行の場合、下に新たに空行を追加して移動
            execute "normal! `<V`>do\<ESC>p`[V`]"
        else
            execute "normal! `<V`>dp`[V`]"
        endif

    "上移動
    elseif a:direction == "UP"
        if topLine == minLine
            "最上行の場合、何もしない
            execute "normal! `<V`>"
            return
        elseif bottomLine == maxLine
            "最下行の場合、カーソル行が上にずれるため、kが必要無い
            execute "normal! `<V`>dP`[V`]"
        else
            execute "normal! `<V`>dkP`[V`]"
        endif
    endif

    let @@ = tmp
endfunction

" 複数行にわたる関数実行
function! MultiLineCall(funcName, args)
    execute "normal! `<"
    let startLine = line('.')
    execute "normal! `>"
    let endLine = line('.')

    let Fn = function(a:funcName, a:args)

    for eachLine in range(startLine, endLine)
        execute "normal! " . eachLine . "G"
        call Fn()
    endfor
endfunction

function! ReplClient(string)
    if !exists("w:ch") || ch_status(w:ch) != "open"
        let w:ch = ch_open("localhost:9000", {"mode": "raw", "callback": "Handler"})
    endif

    execute "normal! \<c-w>wG"
    execute "normal! oIN>>> " . a:string . "\<esc>k$=%"

    execute "normal! \<c-w>w"
    call ch_sendraw(w:ch, a:string)
endfunction

function! Handler(channel, msg)
    execute "normal! \<c-w>wG"
    execute "normal! oOUT>>> " . a:msg . "\<esc>=%"

    execute "normal! \<c-w>w"
    call ch_close(w:ch)
endfunction

autocmd FileType lisp noremap <C-F5> :!start clisp -i C:\vim\server.lisp<CR>:new repl.lisp<CR><C-W>x
autocmd FileType lisp nnoremap <silent> <C-F5> :call StartRepl()<cr>
autocmd FileType lisp nnoremap <silent> <c-cr> V<esc>:call Repl()<cr>
autocmd FileType lisp vnoremap <silent> <c-cr> <esc>`<V`><esc>:call Repl()<cr>

function! Repl()
    call ReplClient(GetSelectedString())
endfunction

function! StartRepl()
    execute '!start clisp -i '.$HOME.'/server.lisp'
    execute "vnew repl.lisp"
    execute "normal! \<c-w>x"
endfunction
